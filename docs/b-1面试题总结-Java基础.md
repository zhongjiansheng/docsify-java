## 2.1 java基础

### 2.1.1 java的特性

* 面向对象：封装、继承和多态

  > **封装**：把对象的属性进行私有化，阻止其他对象的访问，对于允许其他对象能访问的属性则提供公开的方法进行访问。
  >
  > **继承：**选用其中一个类作为基础类，可以通过对该类进行继承，从而拥有该类的方法和属性，并且可以进行自己方法和属性的扩充，但是对于被继承类的私有属性或者方法，只能拥有不能使用。
  >
  > **多态：**调用同一个方法可能返回不同的结果，因为该方法可能来源于不同子类型的对象。多态分为编译时的多态和运行时的多态性。对于方法重载来说是实现的编译时的多态，而方法重写实现的是运行时的多态性。其中运行时的多态主要面向继承和接口实现两方面。

* 自动内存回收

* 数组安全

### 2.1.2 java的引用

**1.引用的作用：**引用的作用类似于*C++的指针*，用来指定所要使用的数据的位置。

**2.引用的作用域：**对于静态引用放在方法区当中，所有类对象都可以使用；对于实例对象引用则放在堆中， 只有该实例对象使用；对于方法中的引用则其作用域为方法内部。

### 2.1.3 基本类型和对象类型的区别

**基本类型：**不能用*new*来创建变量，而是创建一个并非是引用的*自动*变量，这个变量直接存储*值*，放于堆栈中。

**对象类型：**使用*new*创建，并且位于堆中。

### 2.1.4 基本类型的大小

基本类型都有自己的固定的空间，不会随着硬件的改变而改变。

![image-20200616155007553](b-1面试题总结-Java基础.assets/image-20200616155007553.png)

### 2.1.5 包装器和基本类型的区别

每个基本类型都有对应的包装器类型，能够在堆中创建一个非基本类型对象，用来表示基本类型。

**两者区别：**

* 创建方式不同
* 对象所在位置不同
* 对于 Integer 和 int 来说， Integer 的值可以为 null ，而 int 不能为 null
* Integer 的值在 -128 ~127 的时候会缓存，如果创建的新对象在该区间则会调用常量池中的的对象

### 2.1.6 成员变量和局部变量的区别

* **是否初始化：**成员变量可以自动初始化，而局部变量必须人为赋值
* **权限修饰符：**成员变量可以采用任何权限修饰符，而局部变量只可以使用*final*
* **作用域：**成员变量作用域为整个实例对象，而局部变量则是方法内部
* **所处位置：**成员变量的位置为堆，而局部变量则是java堆栈中

### 2.1.7 访问修饰符的区别

public > protected > default > private

| 修饰符    | 当前类 | 同包 | 子类 | 其他包 |
| --------- | ------ | ---- | ---- | ------ |
| public    | √      | √    | √    | √      |
| protected | √      | √    | √    | ×      |
| default   | √      | √    | ×    | ×      |
| private   | √      | ×    | ×    | ×      |

### 2.1.8 String详解

*String*是不可变的的，其底层数据结构是字节数组。

![image-20200616171454098](b-1面试题总结-Java基础.assets/image-20200616171454098.png)

**String 中的 +、+=**是 Java 中仅有的两个重载过得操作符。

* String 的创建方式：

  ```java
  // 首先看字符串常量池中有没对于字符存在，有则直接返回引用地址，没有则创建字符并且返回引用地址
  String str = "a";
  // 在堆上创建一个String对象，如果字符串常量池有对应字符串，则指向该字符串，没有则创建字符并且指向该字符串
  String str1 = new String("a");
  // 在编译期间就进行优化变为”ab“，后面的过程和第一个创建方式一样
  String str2 = "a" + "b";
  // 由于有变量，需要运行时创建，会自动创建new StringBuilder();
  String str3 = "a" + str;
  // 对于final常量，会自动进行替换。
  final String a = "a";
  final String b = "b";
  String c = a + b;
  ```

* String.intern() 解析

  intern() 的使用分为两种，一种是 JDK7 之前，此时对于第一次遇见的字符串会首先在字符串常量池中进行字符串的复制，并且返回引用。还有一种则是 JDK7 ，对于第一次遇见的字符串不是直接在常量池中进行字符串的复制，而是把对应实例对象的引用放入常量池中，并且返回该引用。

### 2.1.9 Math.round(11.5) 和 Math.round(-11.5) 分别等于多少

Math.round(11.5) 的返回值为 12，Math.round(-11.5) 的返回值为 -11。四舍五入的原理是在参数上加*0.5*然后向下取整。

### 2.1.10 为什么 hashCode 和 equal 需要同时重写

hashCode 用来获得对象的哈希码，如果不进行重写的话则默认以对象的内存地址进行编码，那么对象的hashCode 会永远不相等，同样，equal 的默认是比较对象地址是否相等，所以需要两者同时重写。

**hashCode 和 equal 的关系**

> hashCode 相等，不代表 equal相等
>
> equal 相等，则 hashCode 一定 相等

### 2.1.11 java 中方法的传递是值传递还是引用传递？

都是值传递。当为基本类型的时候值传递传递的是基本类型的值副本，所以不会影响原始值。同样，当传递引用对象的时候，传递的是引用对象的地址，会对原始对象进行改变。